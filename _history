{"entries":[{"timestamp":1762623310274,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":784,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":216,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1762623904399,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":109,"length1":31,"diffs":[[1,"     blockedTypeofTile: Image[]\r\n"]]},{"start1":144,"length1":45,"diffs":[[1,"     constructor(tilesetObstacles: Image[]) {\r\n"]]},{"start1":298,"length1":118,"diffs":[[1,""]]},{"start1":401,"length1":2,"diffs":[[1,""]]},{"start1":478,"length1":42,"diffs":[[1,"           \r\n"]]},{"start1":522,"length1":628,"diffs":[[1,"     protected levelEquals(level: number | null | undefined): boolean {\r\n"]]},{"start1":782,"length1":167,"diffs":[[1,""]]}]}]},{"timestamp":1762624506784,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1617,"length1":35,"diffs":[[1,"     const worldMap = new \r\n"]]}]}]},{"timestamp":1762624509096,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":667,"length1":378,"diffs":[[1,""]]},{"start1":1478,"length1":120,"diffs":[[1,""]]},{"start1":1583,"length1":141,"diffs":[[1," export function setWorldMap() {\r\n     const worldMap = new tileMap\r\n"]]},{"start1":1656,"length1":984,"diffs":[[1,"} "]]}]}]},{"timestamp":1762625128629,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":677,"length1":157,"diffs":[[1,"       * sets the world map and progresses  and clears tiles until you progress up to the next level\r\n       */\r\n"]]}]}]},{"timestamp":1762625233220,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2631,"length1":0,"diffs":[[1,"\r\nnew worldMap.TileMap(img`\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n`)"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":24,"diffs":[[1,"    \"name\": \"Untitled\",\n"]]},{"start1":184,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1762623310273,"editorVersion":"2.0.61","text":{"main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1762625125996,"editorVersion":"2.0.61","text":{"main.ts":"namespace worldMap {\r\n export class TileMap {\r\n     tileMap: tiles.TileMap\r\n     protected currentLevel = 0\r\n     blockedTypeofTile: Image\r\n\r\n     constructor(tilesetObstacles: Image) {\r\n         this.tileMap = new tiles.TileMap()\r\n         this.blockedTypeofTile = tilesetObstacles\r\n     }\r\n\r\n    /**\r\n     * sets the world map and progresses  and clears tiles until you progress up to the next level\r\n     */\r\n     setWorldMap(level: number) {\r\n      if (this.levelEquals(level)) {\r\n         this.currentLevel++\r\n\r\n         for (const tile of tiles.getTilesByType(this.blockedTypeofTile)) {\r\n           tiles.setWallAt(tile, false) \r\n         }\r\n      }\r\n     }\r\n\r\n     /**\r\n       * sets the world map and progresses  and clears tiles until you progress up to the next level\r\n       */\r\n     setWorldMapWithReplacedTile(level: number, tile: Image) {\r\n         this.setWorldMap(level)\r\n        \r\n         for (const tileLoc of tiles.getTilesByType(this.blockedTypeofTile)) {\r\n             tiles.setTileAt(tileLoc, tile)\r\n         }\r\n     }\r\n\r\n   /**\r\n    * adds obstacles of the type of the tile image to the tilemap and clears until your progress gets upgraded\r\n    */\r\n     addObstacles(tile: Image) {\r\n         for (const tilsetKindType of tiles.getTilesByType(tile)) {\r\n           tiles.setWallAt(tilsetKindType, true)    \r\n         }\r\n     }\r\n\r\n     /**\r\n   * clears obstacles of the type of the tile image to the tilemap\r\n    */\r\n     removeObstacles(tile: Image) {\r\n         for (const tilsetKindType of tiles.getTilesByType(tile)) {\r\n             tiles.setWallAt(tilsetKindType, false)\r\n         }\r\n     }\r\n\r\n     protected levelEquals(level: number): boolean {\r\n         // if level is null or undefined, treat it as invalid\r\n         if (level === null || level === undefined) return false\r\n         return level === this.currentLevel\r\n     }\r\n\r\n     toString(): string {\r\n         return `${this.tileMap}  ${this.currentLevel} ${this.blockedTypeofTile}`\r\n     }\r\n }\r\n\r\n  /**\r\n   * sets the tilemap and clears tiles and walls until you unlock to the next level\r\n   */\r\n export function setWorldMap(obstacles: Image, level = 0) {\r\n     const worldMap = new TileMap(obstacles)\r\n     worldMap.setWorldMap(level)\r\n }\r\n\r\n    /**\r\n     * sets the tilemap and clears tiles and walls until you unlock to the next level and with a tile replaced the unlock with your new layer tile\r\n     */\r\n    export function setWorldMapWithReplacedTile(obstacles: Image, level = 0) {\r\n    const worldMap = new TileMap(obstacles)\r\n    worldMap.setWorldMapWithReplacedTile(level, obstacles)\r\n }\r\n} \r\n\r\nnew worldMap.TileMap(img`\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n    . . . . . . . . . . . . . . . .\r\n`)","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1762625316412}